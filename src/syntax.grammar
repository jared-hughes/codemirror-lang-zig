@top Root {
  ContainerDocComment?
  containerMembers
  eof
}

@skip {
  space | LineComment
}

@detectDelim

@precedence {
  // stmt-level
  useop,
  extend_if_assign,
  extend_if_block,
  finish_stmt,
  after_assert,
  before_assert,
  after_else,
  before_else,
  after_suffix,
  before_suffix,
  after_label,
  before_label,
  comptime_paramdecl,
  comptime_typeexpr,
  after_typeexpr,
  before_typeexpr,
  inline_loop,
  outline_loop,
  // expr
  prefix,
  multiply @left,
  addition @left,
  bitshift @left,
  bitwise @left,
  compare @left,
  bool_and @left,
  bool_or @left,
  // more
  before_break_label,
  after_break_label,
  expr1,
  expr2,
  expr3
}

// *** Top level ***
containerMembers {
  containerDeclaration* (ContainerField ',')* ContainerField
  | containerDeclaration*
  | containerDeclaration* (ContainerField ',')+ containerDeclaration*
}

containerDeclaration {
  TestDecl { kw<'test'> (StringLiteralSingle | Identifier)? Block }
  | ComptimeDecl { kw<'comptime'> Block }
  | Decl { DocComment? kw<'pub'>? decl }
}
decl {
  (
    kw<'export'>
    | kw<'extern'> StringLiteralSingle?
    | kw<'inline'>
    | kw<'noinline'>
  )? FnProto (';' | Block)
  | (
    kw<'export'>
    | kw<'extern'> StringLiteralSingle?
  )? kw<'threadlocal'>? VarDecl
  | kw<'usingnamespace'> expr ';'
}

FnProto {
  kw<'fn'> Identifier? '(' commaSep<ParamDecl> ')'
    ByteAlign? AddrSpace? LinkSection? CallConv? '!'? TypeExpr
}

VarDecl {
  (kw<'const'> | kw<'var'>) Identifier (':' TypeExpr)?
    ByteAlign? AddrSpace? LinkSection? ('=' expr)? ';'
}

ContainerField {
  DocComment? kw<'comptime'>? (
    Identifier ':' TypeExpr
    | Identifier
    | !before_typeexpr TypeExpr
  ) !after_typeexpr ByteAlign? ('=' expr)?
}

// *** Block Level ***
Statement {
  kw<'comptime'>? VarDecl
  | kw<'comptime'> BlockExprStatement
  | kw<'nosuspend'> BlockExprStatement
  | kw<'suspend'> BlockExprStatement
  | kw<'defer'> BlockExprStatement
  | kw<'errdefer'> Payload? BlockExprStatement
  | IfStatement
  | LabeledStatement
  | SwitchExpr
  | AssignExpr ';'
}

IfStatement {
  IfPrefix BlockExpr
  | IfPrefix AssignExpr ( ';' | kw<'else'> Payload? Statement )
}

LabeledStatement {
  // TODO: this doesn't allow an unlabelled block that's *not* followed by a semicolon
  BlockLabel Block |
  BlockLabel? LoopStatement
}

LoopStatement {
  kw<'inline'>? (ForStatement | WhileStatement)
}

ForStatement {
  ForPrefix BlockExpr
  | ForPrefix AssignExpr ( ';' | kw<'else'> Statement )
}

WhileStatement {
  WhilePrefix BlockExpr
  | WhilePrefix AssignExpr ( ';' | kw<'else'> Payload? Statement )
}

BlockExprStatement {
  BlockExpr
  | expr !finish_stmt ';'
}

BlockExpr {
  BlockLabel Block
}

// *** Expression Level ***
AssignExpr {
  expr !useop (AssignOp expr)?
}

expr {
  BoolOrExpr { expr !bool_or kw<'or'> expr }
  | BoolAndExpr { expr !bool_and kw<'and'> expr }
  | CompareExpr { expr !compare CompareOp expr }
  | BitwiseExpr { expr !bitwise BitwiseOp expr }
  | BitShiftExpr { expr !bitshift BitShiftOp expr }
  | AdditionExpr { expr !addition AdditionOp expr }
  | MultiplyExpr { expr !multiply MultiplyOp expr }
  | PrefixExpr { !prefix PrefixOp expr }
  | primaryExpr
}

primaryExpr {
  AsmExpr
  | IfExpr
  | kw<'break'> (!before_break_label BreakLabel)? !after_break_label expr?
  | kw<'comptime'> !useop expr
  | kw<'nosuspend'> expr
  | kw<'continue'> (!before_break_label BreakLabel)? !after_break_label
  | kw<'resume'> expr
  | kw<'return'> expr?
  | BlockLabel? LoopExpr
  | Block
  // TODO:
  // | CurlySuffixExpr { TypeExpr InitList? }
  // Integer and following are temporary here to pass tests. CurlySuffixExpr needs to be impl'd.
  | Integer
  | StringLiteral
  | BuiltinIdentifier FnCallArguments
}

IfExpr {
  IfPrefix expr (!before_else kw<'else'> Payload? expr)? !after_else
}

Block {
  '{' Statement* '}'
}

LoopExpr {
  kw<'inline'> (ForExpr | WhileExpr) !inline_loop
  | (ForExpr | WhileExpr) !outline_loop
}

ForExpr {
  ForPrefix expr (!before_else kw<'else'> expr)? !after_else
}

WhileExpr {
  WhilePrefix expr (!before_else kw<'else'> Payload? expr)? !after_else
}

InitList {
  '{' FieldInit (',' FieldInit)* ','? '}'
  | '{' expr (',' expr)* ','? '}'
  | '{' '}'
}

TypeExpr {
  PrefixTypeOp* suffixExpr (!before_assert '!' TypeExpr)? !after_assert
}

suffixExpr {
  kw<'async'> primaryTypeExpr SuffixOp* FnCallArguments
  | primaryTypeExpr (!before_suffix SuffixOp | FnCallArguments)* !after_suffix
}

primaryTypeExpr {
  BuiltinIdentifier FnCallArguments
  | CharLiteral
  | ContainerDecl
  | '.' Identifier
  | '.' InitList
  | ErrorSetDecl
  | Float
  | FnProto
  | GroupedExpr
  | LabeledTypeExpr
  | Identifier
  | IfTypeExpr
  | Integer
  | !comptime_typeexpr kw<'comptime'> TypeExpr
  | kw<'error'> '.' Identifier
  | kw<'anyframe'>
  | kw<'unreachable'>
  | StringLiteral
  | SwitchExpr
}

ContainerDecl {
  (kw<'extern'> | kw<'packed'>)? ContainerDeclAuto
}

ErrorSetDecl {
  kw<'error'> '{' commaSep<DocComment? Identifier> '}'
}

GroupedExpr {
  '(' expr ')'
}

IfTypeExpr {
  IfPrefix TypeExpr (!before_else kw<'else'> Payload? TypeExpr)? !after_else
}

LabeledTypeExpr {
  BlockLabel Block
  | (!before_label BlockLabel)? !after_label LoopTypeExpr
}

LoopTypeExpr {
  kw<'inline'>? (ForTypeExpr | WhileTypeExpr)
}

ForTypeExpr {
  ForPrefix TypeExpr (!before_else kw<'else'> TypeExpr)? !after_else
}

WhileTypeExpr {
  WhilePrefix TypeExpr (!before_else kw<'else'> Payload? TypeExpr)? !after_else
}

SwitchExpr {
  kw<'switch'> '(' expr ')' '{' commaSep<SwitchProng> '}'
}

// *** Assembly ***
AsmExpr {
  kw<'asm'> kw<'volatile'>? '(' expr AsmOutput? ')'
}

AsmOutput {
  ':' commaSep<AsmOutputItem> AsmInput?
}

AsmOutputItem {
  '[' Identifier ']' StringLiteral '(' ('->' TypeExpr | Identifier) ')'
}

AsmInput {
  ':' commaSep<AsmInputItem> AsmClobbers?
}

AsmInputItem {
  '[' Identifier ']' StringLiteral '(' expr ')'
}

AsmClobbers {
  ':' commaSep<StringLiteral>
}

// *** Helper grammar ***
BreakLabel {
  ':' Identifier
}

BlockLabel {
  Identifier ':'
}

FieldInit {
  '.' Identifier '=' expr
}

WhileContinueExpr {
  ':' '(' AssignExpr ')'
}

LinkSection {
  kw<'linksection'> '(' expr ')'
}

AddrSpace {
  kw<'addrspace'> '(' expr ')'
}

// Fn specific
CallConv {
  kw<'callconv'> '(' expr ')'
}

ParamDecl {
  DocComment?
    (
      kw<'noalias'>
      | !comptime_paramdecl kw<'comptime'>
    )?
    (Identifier ':')? 
    (kw<'anytype'> | TypeExpr)
  | '...'
}

// Control flow prefixes
IfPrefix {
  kw<'if'> '(' expr ')' PtrPayload?
}

WhilePrefix {
  kw<'while'> '(' expr ')' PtrPayload? WhileContinueExpr?
}

ForPrefix {
  kw<'for'> '(' ForArgumentsList ')' PtrListPayload
}

// Payloads
Payload {
  '|' Identifier '|'
}

PtrPayload {
  '|' '*'? Identifier '|'
}

PtrIndexPayload {
  '|' '*'? Identifier (',' Identifier)? '|'
}

PtrListPayload {
  '|' '*'? Identifier (',' '*'? Identifier)* ','? '|'
}

// Switch specific
SwitchProng {
  kw<'inline'>? SwitchCase '=>' PtrIndexPayload? AssignExpr
}

SwitchCase {
  SwitchItem (',' SwitchItem)* ','?
  | kw<'else'>
}

SwitchItem {
  expr ('...' expr)?
}

// For specific
ForArgumentsList {
  ForItem (',' ForItem)* ','?
}

ForItem {
  expr ('..' expr?)?
}

// Operators
AssignOp {
  '*='
  | '*|='
  | '/='
  | '%='
  | '+='
  | '+|='
  | '-='
  | '-|='
  | '<<='
  | '<<|='
  | '>>='
  | '&='
  | '^='
  | '|='
  | '*%='
  | '+%='
  | '-%='
  | '='
}

CompareOp {
  '=='
  | '!='
  | '<'
  | '>'
  | '<='
  | '>='
}

BitwiseOp {
  '&'
  | '^'
  | '|'
  | kw<'orelse'>
  | kw<'catch'> Payload?
}

BitShiftOp {
  '<<'
  | '>>'
  | '<<|'
}

AdditionOp {
  '+'
  | '-'
  | '++'
  | '+%'
  | '-%'
  | '+|'
  | '-|'
}

MultiplyOp {
  '||'
  | '*'
  | '/'
  | '%'
  | '**'
  | '*%'
  | '*|'
}

PrefixOp {
  '!'
  | '-'
  | '~'
  | '-%'
  | '&'
  | kw<'try'>
  | kw<'await'>
}

PrefixTypeOp {
  '?'
  | kw<'anyframe'> '->'
  | SliceTypeStart (ByteAlign | AddrSpace | kw<'const'> | kw<'volatile'> | kw<'allowzero'>)*
  | PtrTypeStart (AddrSpace | kw<'align'> '(' expr (':' expr ':' expr)? ')' | kw<'const'> | kw<'volatile'> | kw<'allowzero'>)*
  | ArrayTypeStart
}

SuffixOp {
  '[' expr ('..' (expr? (':' expr)?)?)? ']'
  | '.' Identifier
  | '.*'
  | '.?'
}

FnCallArguments {
  '(' commaSep<expr> ')'
}

//  Ptr specific
SliceTypeStart {
  '[' (':' expr)? ']'
}

PtrTypeStart {
  '*'
  | '**'
  | '[' '*' ('c' | ':' expr)? ']'
}

ArrayTypeStart {
  '[' expr (':' expr)? ']'
}

// ContainerDecl specific
ContainerDeclAuto {
  ContainerDeclType '{' ContainerDocComment? containerMembers '}'
}

ContainerDeclType {
  kw<'struct'> ('(' expr ')')?
  | kw<'opaque'>
  | kw<'enum'> ('(' expr ')')?
  | kw<'union'> ('(' (kw<'enum'> ('(' expr ')')? | expr) ')')?
}

// Alignment
ByteAlign { kw<'align'> '(' expr ')' }

commaSep<e> { "" | e (',' e)* }

@tokens {
  eof { @eof }

  bin { $[01] }
  oct { $[0-7] }
  dec { $[0-9] }
  hex { $[0-9a-fA-F] }

  bin_ { '_'? bin }
  oct_ { '_'? oct }
  hex_ { '_'? hex }
  dec_ { '_'? dec }

  bin_int { bin bin_* }
  oct_int { oct oct_* }
  hex_int { hex hex_* }
  dec_int { dec dec_* }

  // TODO: lezer operates on chars not bytes
  ox80_oxBF { $[\u0080-\u00bf] }
  oxF4 { '\u00f4' }
  ox80_ox8F { $[\u0080-\u008f] }
  oxF1_oxF3 { $[\u00f1-\u00f3] }
  oxF0 { '\u00f0' }
  ox90_0xBF { $[\u0090-\u00bf] }
  oxEE_oxEF { $[\u00ee-\u00ef] }
  oxED { '\u00ed' }
  ox80_ox9F { $[\u0080-\u009f] }
  oxE1_oxEC { $[\u00e1-\u00ec] }
  oxE0 { '\u00e0' }
  oxA0_oxBF { $[\u00a0-\u00bf] }
  oxC2_oxDF { $[\u00c2-\u00df] }

  mb_utf8_literal {
    oxF4      ox80_ox8F ox80_oxBF ox80_oxBF
    | oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF
    | oxF0      ox90_0xBF ox80_oxBF ox80_oxBF
    | oxEE_oxEF ox80_oxBF ox80_oxBF
    | oxED      ox80_ox9F ox80_oxBF
    | oxE1_oxEC ox80_oxBF ox80_oxBF
    | oxE0      oxA0_oxBF ox80_oxBF
    | oxC2_oxDF ox80_oxBF
  }

  ascii_char_not_nl_slash_squote { $[\u0000-\u0009\u000b-\u0026\u0028-\u005b\u005d-\u007f] }

  char_escape {
    "\\x" hex hex
    | "\\u{" hex+ "}"
    | "\\" $[nr\\t'"]
  }

  char_char {
    mb_utf8_literal
    | char_escape
    | ascii_char_not_nl_slash_squote
  }

  string_char {
    char_escape
    | ![\\"\n]
  }

  @precedence {
    DocComment, ContainerDocComment,
    LineComment,
    '/'
  }

  ContainerDocComment { ('//!' ![\n]* $[ \n]*)+ }
  DocComment { ('///' ![\n]* $[ \n]*)+ }
  LineComment { '//' ![\n]* | '////' ![\n]* }
  LineString { ("\\\\" ![\n]* $[ \n]*)+ }
  space { $[ \n] }

  CharLiteral { "'" char_char "'" }
  @precedence {
    Float,
    Integer
  }
  Float {
    "0x" hex_int "." hex_int ($[pP] $[-+]? dec_int)?
    |      dec_int "." dec_int ($[eE] $[-+]? dec_int)?
    | "0x" hex_int $[pP] $[-+]? dec_int
    |      dec_int $[eE] $[-+]? dec_int
  }
  Integer {
    "0b" bin_int
    | "0o" oct_int
    | "0x" hex_int
    |      dec_int
  }
  stringLiteralSingle { "\"" string_char* "\"" }
  StringLiteralSingle[@name=StringLiteral] { stringLiteralSingle }
  StringLiteral {
    stringLiteralSingle
      | (LineString   )+
  }
  Identifier {
    $[A-Za-z_] $[A-Za-z0-9_]*
    | "@" stringLiteralSingle
  }
  BuiltinIdentifier { "@" $[A-Za-z_] $[A-Za-z0-9_]* }

  @precedence {
    '&=',
    '&'
  }
  '&' '&='
  @precedence {
    '*%=', '*|=',
    '*%', '*|', '*=', '**',
    '*'
  }
  '*' '**' '*=' '*%' '*%=' '*|' '*|='
  @precedence {
    '^=',
    '^'
  }
  '^' '^=' ':' ','
  @precedence {
    '...',
    '..', '.*', '.?',
    '.'
  }
  '.' '..' '...' '.*' '.?'
  @precedence {
    '==', '=>',
    '='
  }
  '=' '==' '=>'
  @precedence {
    '!=',
    '!'
  }
  '!' '!='
  @precedence {
    '<<|=',
    '<<=', '<<|',
    '<<', '<=',
    '<'
  }
  '<' '<<' '<<=' '<<|' '<<|=' '<=' '{' '[' '('   
  @precedence {
    '-%=', '-|='
    '-=', '-%', '->', '-|',
    '-'
  }
  '-' '-=' '-%' '-%=' '-|' '-|=' '->'  
  @precedence {
    '%=',
    '%'
  }
  '%' '%=' 
  @precedence {
    '||', '|=',
    '|'
  }
  '|' '||' '|='
  @precedence {
    '+%=', '+|=',
    '++', '+=', '+%', '+|',
    '+'
  }
  '+' '++' '+=' '+%' '+%=' '+|' '+|=' 'c' '?'    
  @precedence {
    '>>=',
    '>>', '>=',
    '>'
  }
  '>' '>>' '>>=' '>=' '}'  ']'  ')' ';'    
  @precedence {
    '/=',
    '/'
  }
  '/' '/=' '~'    
}

kw<word> { @specialize[@name={word}]<Identifier, word> }
