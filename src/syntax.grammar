@top Root {
  ContainerDocComment?
  ContainerMembers
  eof
}

@skip {
  space | LineComment
}

@detectDelim

@precedence {
  // stmt-level
  useop,
  extend_if_assign,
  extend_if_block,
  finish_stmt,
  after_assert,
  before_assert,
  after_else,
  before_else,
  after_suffix,
  before_suffix,
  after_label,
  before_label,
  comptime_paramdecl,
  comptime_typeexpr,
  after_typeexpr,
  before_typeexpr,
  inline_loop,
  outline_loop,
  // expr
  prefix,
  multiply @left,
  addition @left,
  bitshift @left,
  bitwise @left,
  compare @left,
  bool_and @left,
  bool_or @left,
  // more
  before_break_label,
  after_break_label,
  expr1,
  expr2,
  expr3
}

// *** Top level ***
ContainerMembers {
  ContainerDeclarations (ContainerField ',')* (ContainerField | ContainerDeclarations)
}

ContainerDeclarations {
  TestDecl ContainerDeclarations
  | ComptimeDecl ContainerDeclarations
  | DocComment? kw<'pub'>? Decl ContainerDeclarations
}
TestDecl {
  kw<'test'> (stringLiteralSingle | Identifier)? Block
}
ComptimeDecl {
  kw<'comptime'> Block
}

Decl {
  (kw<'export'> | kw<'extern'> stringLiteralSingle? | (kw<'inline'> | kw<'noinline'>))? FnProto (';' | Block)
  | (kw<'export'> | kw<'extern'> stringLiteralSingle?)? kw<'threadlocal'>? VarDecl
  | kw<'usingnamespace'> Expr ';'
}

FnProto {
  kw<'fn'> Identifier? '(' ParamDeclList ')' ByteAlign? AddrSpace? LinkSection? CallConv? '!'? TypeExpr
}

VarDecl {
  (kw<'const'> | kw<'var'>) Identifier (':' TypeExpr)? ByteAlign? AddrSpace? LinkSection? ('=' Expr)? ';'
}

ContainerField {
  DocComment? kw<'comptime'>? (
    Identifier ':' TypeExpr
    | Identifier
    | !before_typeexpr TypeExpr
  ) !after_typeexpr ByteAlign? ('=' Expr)?
}

// *** Block Level ***
Statement {
  kw<'comptime'>? VarDecl
  | kw<'comptime'> BlockExprStatement
  | kw<'nosuspend'> BlockExprStatement
  | kw<'suspend'> BlockExprStatement
  | kw<'defer'> BlockExprStatement
  | kw<'errdefer'> Payload? BlockExprStatement
  | IfStatement
  | LabeledStatement
  | SwitchExpr
  | AssignExpr ';'
}

IfStatement {
  IfPrefix BlockExpr
  | IfPrefix AssignExpr ( ';' | kw<'else'> Payload? Statement )
}

LabeledStatement {
  // TODO: this doesn't allow an unlabelled block that's *not* followed by a semicolon
  BlockLabel Block |
  BlockLabel? LoopStatement
}

LoopStatement {
  kw<'inline'>? (ForStatement | WhileStatement)
}

ForStatement {
  ForPrefix BlockExpr
  | ForPrefix AssignExpr ( ';' | kw<'else'> Statement )
}

WhileStatement {
  WhilePrefix BlockExpr
  | WhilePrefix AssignExpr ( ';' | kw<'else'> Payload? Statement )
}

BlockExprStatement {
  BlockExpr
  | Expr !finish_stmt ';'
}

BlockExpr {
  BlockLabel Block
}

// *** Expression Level ***
AssignExpr {
  Expr !useop (AssignOp Expr)?
}

Expr {
  BoolOrExpr { Expr !bool_or kw<'or'> Expr } |
  BoolAndExpr { Expr !bool_and kw<'and'> Expr } |
  CompareExpr { Expr !compare CompareOp Expr } |
  BitwiseExpr { Expr !bitwise BitwiseOp Expr } |
  BitShiftExpr { Expr !bitshift BitShiftOp Expr } |
  AdditionExpr { Expr !addition AdditionOp Expr } |
  MultiplyExpr { Expr !multiply MultiplyOp Expr } |
  PrefixExpr { !prefix PrefixOp Expr } |
  PrimaryExpr
}

PrimaryExpr {
  AsmExpr
  | IfExpr
  | kw<'break'> (!before_break_label BreakLabel)? !after_break_label Expr?
  | kw<'comptime'> !useop Expr
  | kw<'nosuspend'> Expr
  | kw<'continue'> (!before_break_label BreakLabel)? !after_break_label
  | kw<'resume'> Expr
  | kw<'return'> Expr?
  | BlockLabel? LoopExpr
  | Block
  // TODO:
  // | CurlySuffixExpr { TypeExpr InitList? }
}

IfExpr {
  IfPrefix Expr (!before_else kw<'else'> Payload? Expr)? !after_else
}

Block {
  '{' Statement* '}'
}

LoopExpr {
  kw<'inline'> (ForExpr | WhileExpr) !inline_loop
  | (ForExpr | WhileExpr) !outline_loop
}

ForExpr {
  ForPrefix Expr (!before_else kw<'else'> Expr)? !after_else
}

WhileExpr {
  WhilePrefix Expr (!before_else kw<'else'> Payload? Expr)? !after_else
}

InitList {
  '{' FieldInit (',' FieldInit)* ','? '}'
  | '{' Expr (',' Expr)* ','? '}'
  | '{' '}'
}

TypeExpr {
  PrefixTypeOp* SuffixExpr (!before_assert '!' TypeExpr)? !after_assert
}

SuffixExpr {
  kw<'async'> PrimaryTypeExpr SuffixOp* FnCallArguments
  | PrimaryTypeExpr (!before_suffix SuffixOp | FnCallArguments)* !after_suffix
}

PrimaryTypeExpr {
  BuiltinIdentifier FnCallArguments
  | CharLiteral
  | ContainerDecl
  | '.' Identifier
  | '.' InitList
  | ErrorSetDecl
  | Float
  | FnProto
  | GroupedExpr
  | LabeledTypeExpr
  | Identifier
  | IfTypeExpr
  | Integer
  | !comptime_typeexpr kw<'comptime'> TypeExpr
  | kw<'error'> '.' Identifier
  | kw<'anyframe'>
  | kw<'unreachable'>
  | StringLiteral
  | SwitchExpr
}

ContainerDecl {
  (kw<'extern'> | kw<'packed'>)? ContainerDeclAuto
}

ErrorSetDecl {
  kw<'error'> '{' IdentifierList '}'
}

GroupedExpr {
  '(' Expr ')'
}

IfTypeExpr {
  IfPrefix TypeExpr (!before_else kw<'else'> Payload? TypeExpr)? !after_else
}

LabeledTypeExpr {
  BlockLabel Block
  | (!before_label BlockLabel)? !after_label LoopTypeExpr
}

LoopTypeExpr {
  kw<'inline'>? (ForTypeExpr | WhileTypeExpr)
}

ForTypeExpr {
  ForPrefix TypeExpr (!before_else kw<'else'> TypeExpr)? !after_else
}

WhileTypeExpr {
  WhilePrefix TypeExpr (!before_else kw<'else'> Payload? TypeExpr)? !after_else
}

SwitchExpr {
  kw<'switch'> '(' Expr ')' '{' SwitchProngList '}'
}

// *** Assembly ***
AsmExpr {
  kw<'asm'> kw<'volatile'>? '(' Expr AsmOutput? ')'
}

AsmOutput {
  ':' AsmOutputList AsmInput?
}

AsmOutputItem {
  '[' Identifier ']' StringLiteral '(' ('->' TypeExpr | Identifier) ')'
}

AsmInput {
  ':' AsmInputList AsmClobbers?
}

AsmInputItem {
  '[' Identifier ']' StringLiteral '(' Expr ')'
}

AsmClobbers {
  ':' StringList
}

// *** Helper grammar ***
BreakLabel {
  ':' Identifier
}

BlockLabel {
  Identifier ':'
}

FieldInit {
  '.' Identifier '=' Expr
}

WhileContinueExpr {
  ':' '(' AssignExpr ')'
}

LinkSection {
  kw<'linksection'> '(' Expr ')'
}

AddrSpace {
  kw<'addrspace'> '(' Expr ')'
}

// Fn specific
CallConv {
  kw<'callconv'> '(' Expr ')'
}

ParamDecl {
  DocComment? (
    kw<'noalias'>
    | !comptime_paramdecl kw<'comptime'>
  )? (Identifier ':')? ParamType
  | '...'
}

ParamType {
  kw<'anytype'>
  | TypeExpr
}

// Control flow prefixes
IfPrefix {
  kw<'if'> '(' Expr ')' PtrPayload?
}

WhilePrefix {
  kw<'while'> '(' Expr ')' PtrPayload? WhileContinueExpr?
}

ForPrefix {
  kw<'for'> '(' ForArgumentsList ')' PtrListPayload
}

// Payloads
Payload {
  '|' Identifier '|'
}

PtrPayload {
  '|' '*'? Identifier '|'
}

PtrIndexPayload {
  '|' '*'? Identifier (',' Identifier)? '|'
}

PtrListPayload {
  '|' '*'? Identifier (',' '*'? Identifier)* ','? '|'
}

// Switch specific
SwitchProng {
  kw<'inline'>? SwitchCase '=>' PtrIndexPayload? AssignExpr
}

SwitchCase {
  SwitchItem (',' SwitchItem)* ','?
  | kw<'else'>
}

SwitchItem {
  Expr ('...' Expr)?
}

// For specific
ForArgumentsList {
  ForItem (',' ForItem)* ','?
}

ForItem {
  Expr ('..' Expr?)?
}

// Operators
AssignOp {
  '*='
  | '*|='
  | '/='
  | '%='
  | '+='
  | '+|='
  | '-='
  | '-|='
  | '<<='
  | '<<|='
  | '>>='
  | '&='
  | '^='
  | '|='
  | '*%='
  | '+%='
  | '-%='
  | '='
}

CompareOp {
  '=='
  | '!='
  | '<'
  | '>'
  | '<='
  | '>='
}

BitwiseOp {
  '&'
  | '^'
  | '|'
  | kw<'orelse'>
  | kw<'catch'> Payload?
}

BitShiftOp {
  '<<'
  | '>>'
  | '<<|'
}

AdditionOp {
  '+'
  | '-'
  | '++'
  | '+%'
  | '-%'
  | '+|'
  | '-|'
}

MultiplyOp {
  '||'
  | '*'
  | '/'
  | '%'
  | '**'
  | '*%'
  | '*|'
}

PrefixOp {
  '!'
  | '-'
  | '~'
  | '-%'
  | '&'
  | kw<'try'>
  | kw<'await'>
}

PrefixTypeOp {
  '?'
  | kw<'anyframe'> '->'
  | SliceTypeStart (ByteAlign | AddrSpace | kw<'const'> | kw<'volatile'> | kw<'allowzero'>)*
  | PtrTypeStart (AddrSpace | kw<'align'> '(' Expr (':' Expr ':' Expr)? ')' | kw<'const'> | kw<'volatile'> | kw<'allowzero'>)*
  | ArrayTypeStart
}

SuffixOp {
  '[' Expr ('..' (Expr? (':' Expr)?)?)? ']'
  | '.' Identifier
  | '.*'
  | '.?'
}

FnCallArguments {
  '(' ExprList ')'
}

//  Ptr specific
SliceTypeStart {
  '[' (':' Expr)? ']'
}

PtrTypeStart {
  '*'
  | '**'
  | '[' '*' ('c' | ':' Expr)? ']'
}

ArrayTypeStart {
  '[' Expr (':' Expr)? ']'
}

// ContainerDecl specific
ContainerDeclAuto {
  ContainerDeclType '{' ContainerDocComment? ContainerMembers '}'
}

ContainerDeclType {
  kw<'struct'> ('(' Expr ')')?
  | kw<'opaque'>
  | kw<'enum'> ('(' Expr ')')?
  | kw<'union'> ('(' (kw<'enum'> ('(' Expr ')')? | Expr) ')')?
}

// Alignment
ByteAlign {
  kw<'align'> '(' Expr ')'
}

// Lists
IdentifierList { commaSep<DocComment? Identifier> }
SwitchProngList { commaSep<SwitchProng> }
AsmOutputList { commaSep<AsmOutputItem> }
AsmInputList { commaSep<AsmInputItem> }
StringList { commaSep<StringLiteral> }
ParamDeclList { commaSep<ParamDecl> }
ExprList { commaSep<Expr> }

commaSep<e> { "" | e (',' e)* }

@tokens {
  eof { @eof }

  bin { $[01] }
  oct { $[0-7] }
  dec { $[0-9] }
  hex { $[0-9a-fA-F] }

  bin_ { '_'? bin }
  oct_ { '_'? oct }
  hex_ { '_'? hex }
  dec_ { '_'? dec }

  bin_int { bin bin_* }
  oct_int { oct oct_* }
  hex_int { hex hex_* }
  dec_int { dec dec_* }

  // TODO: lezer operates on chars not bytes
  ox80_oxBF { $[\u0080-\u00bf] }
  oxF4 { '\u00f4' }
  ox80_ox8F { $[\u0080-\u008f] }
  oxF1_oxF3 { $[\u00f1-\u00f3] }
  oxF0 { '\u00f0' }
  ox90_0xBF { $[\u0090-\u00bf] }
  oxEE_oxEF { $[\u00ee-\u00ef] }
  oxED { '\u00ed' }
  ox80_ox9F { $[\u0080-\u009f] }
  oxE1_oxEC { $[\u00e1-\u00ec] }
  oxE0 { '\u00e0' }
  oxA0_oxBF { $[\u00a0-\u00bf] }
  oxC2_oxDF { $[\u00c2-\u00df] }

  mb_utf8_literal {
    oxF4      ox80_ox8F ox80_oxBF ox80_oxBF
    | oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF
    | oxF0      ox90_0xBF ox80_oxBF ox80_oxBF
    | oxEE_oxEF ox80_oxBF ox80_oxBF
    | oxED      ox80_ox9F ox80_oxBF
    | oxE1_oxEC ox80_oxBF ox80_oxBF
    | oxE0      oxA0_oxBF ox80_oxBF
    | oxC2_oxDF ox80_oxBF
  }

  ascii_char_not_nl_slash_squote { $[\u0000-\u0009\u000b-\u0026\u0028-\u005b\u005d-\u007f] }

  char_escape {
    "\\x" hex hex
    | "\\u{" hex+ "}"
    | "\\" $[nr\\t'"]
  }

  char_char {
    mb_utf8_literal
    | char_escape
    | ascii_char_not_nl_slash_squote
  }

  string_char {
    char_escape
    | $[^\\"\n]
  }

  @precedence {
    DocComment, ContainerDocComment,
    LineComment,
    '/'
  }

  ContainerDocComment { ('//!' ![\n]* ![ \n]*)+ }
  DocComment { ('///' ![\n]* $[ \n]*)+ }
  LineComment { '//' ![\n]* | '////' ![\n]* }
  LineString { ("\\\\" ![\n]* $[ \n]*)+ }
  space { $[ \n] }

  CharLiteral { "'" char_char "'" }
  @precedence {
    Float,
    Integer
  }
  Float {
    "0x" hex_int "." hex_int ($[pP] $[-+]? dec_int)?
    |      dec_int "." dec_int ($[eE] $[-+]? dec_int)?
    | "0x" hex_int $[pP] $[-+]? dec_int
    |      dec_int $[eE] $[-+]? dec_int
  }
  Integer {
    "0b" bin_int
    | "0o" oct_int
    | "0x" hex_int
    |      dec_int
  }
  stringLiteralSingle { "\"" string_char* "\"" }
  StringLiteral {
    stringLiteralSingle
      | (LineString   )+
  }
  Identifier {
    $[A-Za-z_] $[A-Za-z0-9_]*
    | "@" stringLiteralSingle
  }
  BuiltinIdentifier { "@" $[A-Za-z_] $[A-Za-z0-9_]* }

  @precedence {
    '&=',
    '&'
  }
  '&' '&='
  @precedence {
    '*%=', '*|=',
    '*%', '*|', '*=', '**',
    '*'
  }
  '*' '**' '*=' '*%' '*%=' '*|' '*|='
  @precedence {
    '^=',
    '^'
  }
  '^' '^=' ':' ','
  @precedence {
    '...',
    '..', '.*', '.?',
    '.'
  }
  '.' '..' '...' '.*' '.?'
  @precedence {
    '==', '=>',
    '='
  }
  '=' '==' '=>'
  @precedence {
    '!=',
    '!'
  }
  '!' '!='
  @precedence {
    '<<|=',
    '<<=', '<<|',
    '<<', '<=',
    '<'
  }
  '<' '<<' '<<=' '<<|' '<<|=' '<=' '{' '['   
  '('   
  @precedence {
    '-%=', '-|='
    '-=', '-%', '->', '-|',
    '-'
  }
  '-' '-=' '-%' '-%=' '-|' '-|=' '->'  
  @precedence {
    '%=',
    '%'
  }
  '%' '%=' 
  @precedence {
    '||', '|=',
    '|'
  }
  '|' '||' '|='
  @precedence {
    '+%=', '+|=',
    '++', '+=', '+%', '+|',
    '+'
  }
  '+' '++' '+=' '+%' '+%=' '+|' '+|=' 'c' '?'    
  @precedence {
    '>>=',
    '>>', '>=',
    '>'
  }
  '>' '>>' '>>=' '>=' '}'  ']'  ')' ';'    
  @precedence {
    '/=',
    '/'
  }
  '/' '/=' '~'    
}

kw<word> { @specialize[@name={word}]<Identifier, word> }
